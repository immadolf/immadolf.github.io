<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="weiyu luo,fqluowy@gmail.com"><title>immadolf</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords" content="Hexo,Java,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">immadolf</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://github.com/immadolf"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/13/RabbitMQ教程翻译六/">RabbitMQ教程翻译六</a></h3></div><div class="post-content"><p>Remote procedure call (RPC)RPC（远程过程调用）在第二章中我们学习了如何使用工作队列在多个工作线程中分发耗时的任务。
但是如果我们需要调用远程计算机上的某个函数并等待它的结果呢？这种形式被称为远程方法调用。
在这一节中，我们将使用RabbitMQ构建一个RPC系统：一个客户端和一个可扩...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/13/RabbitMQ教程翻译五/">RabbitMQ教程翻译五</a></h3></div><div class="post-content"><p>Topics主题在之前的部分中，我们改进了我们的日志系统，用direct类型的exchange来代替fanout类型的exchange为其增加了根据日志级别来接收消息的能力。
然而使用direct类型依然存在着限制——不能根据多个标准来进行订阅。
我们可能有时候不仅仅想通过日志级别来订阅，还想根据发送消息的源来订...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/13/RabbitMQ教程翻译四/">RabbitMQ教程翻译四</a></h3></div><div class="post-content"><p>Routing路由在上一章中我们已经构建了一个基于广播的日志系统。在这一部分，我们为其添加订阅功能，即只让关键性的错误信息写到磁盘上，其余的日志信息依然输出到屏幕上。
绑定前一节中我们已经介绍了绑定：
1channel.queueBind(queueName, EXCHANGE_NAME, "");
绑定是exc...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/13/RabbitMQ教程翻译三/">RabbitMQ教程翻译三</a></h3></div><div class="post-content"><p>Publish/Subscribe发布/订阅在上一章中我们创建了一个工作队列。它是把每个消息分发给某一个消费者。在这一章中，我们会尝试把一个消息发送给多个消费者。这个模式被称为”发布/订阅”模式。
为了介绍这个模式，我们将构建一个简单的日志系统。它包含两个程序——一个用来提交日志信息，另一个用来接收信息并输出。
...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/13/RabbitMQ教程翻译二/">RabbitMQ教程翻译二</a></h3></div><div class="post-content"><p>Work queues工作队列在上一节中，我们编写了一个往特定队列发送消息和一个从特定队列接收消息的程序。在这一节中，我们会创建一个在多个消费者之间分发耗时任务的工作队列。
工作队列（或者说任务队列）背后的主要思想是避免立即执行资源密集型计算以至于不得不等待它完成。与通过调度任务让它稍后执行不同，我们把一个任务封...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/02/01/RabbitMQ教程翻译一/">RabbitMQ教程翻译一</a></h3></div><div class="post-content"><p>“Hello World”介绍RabbitMQ是一个消息中间件：它接收消息然后转发消息。你可以把它看做一个邮局：当你把邮件投入信箱时你可以肯定邮递员先生最终会把邮件送到你的收件人那里。在这个类比中，RabbitMQ就是一个邮箱，一个邮局以及一个邮递员。
RabbitMQ和邮局之间最主要的区别是RabbitMQ不处...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/RabbitMQ/" title="RabbitMQ">RabbitMQ </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">上一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>